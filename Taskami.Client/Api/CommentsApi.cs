// <auto-generated>
/*
 * Todoist API
 *
 * # Developing with Todoist  Thanks for your interest in developing apps with Todoist. In this section we will provide an overview of the API we offer and cover some common topics for application development using them.  You can use our API for free, but depending on your Todoist account plan (or that of the authenticated user), some features may be restricted.  Please consider subscribing to the [Todoist API mailing list](https://groups.google.com/a/doist.com/g/todoist-api) to get important updates.  ## Our API  Our API uses an approach that should be familiar to anyone with experience calling [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) APIs.  We also have a special endpoint called `/sync`, which is used by our first-party clients to keep the data updated locally without having to make many separate requests to the API. Anyone can use it, and some actions will only be available via `/sync`. The format is unconventional compared to current API standards, but it is our main driver for first-party apps.  ## Our SDKs  Our Python and JavaScript SDKs streamline working with the Todoist API, and can be installed from the main package registries for each ecosystem.  For instructions, examples, and reference documentation, visit their pages:  - [Todoist Python SDK](https://doist.github.io/todoist-api-python/) - [Todoist TypeScript SDK](https://doist.github.io/todoist-api-typescript/)  ## Pagination  Paginated endpoints are marked by having the `next_cursor` attribute in the response.  When a response comes back with `next_cursor: null`, it means the endpoint is paginated but there are no more pages to request data from.  If the cursor is `non-null`, there are more objects to return, and a new request is necessary to get the next page.  The `next_cursor` contains an _opaque_ string that shouldn't be modified in any way. It should be sent **as-is** in the `cursor` parameter along with the same parameters used in the previous request.  ## Integrations  Integrations can be created and updated [here](https://app.todoist.com/app/settings/integrations/app-management).  Once done, they can also be submitted for evaluation and inclusion in [our official integrations list](https://www.todoist.com/integrations). This not only serves as an opportunity to market your integration to our audience, but will also serve as a way to help users get set up and familiar with your app quickly.  To get your integration evaluated, please submit it via [this page](https://doist.typeform.com/to/Vvq7kNcl?typeform-source=todoist.com/api/v1/docs).  Lost? Reach out to us at [submissions@doist.com](mailto:submissions@doist.com) anytime. 
 *
 * The version of the OpenAPI document: 1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ICommentsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        CommentsApiEvents Events { get; }

        /// <summary>
        /// Create Comment
        /// </summary>
        /// <remarks>
        /// Creates a new comment on a project or task and returns it.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCommentApiV1CommentsPostApiResponse"/>&gt;</returns>
        Task<ICreateCommentApiV1CommentsPostApiResponse> CreateCommentApiV1CommentsPostAsync(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Comment
        /// </summary>
        /// <remarks>
        /// Creates a new comment on a project or task and returns it.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </remarks>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCommentApiV1CommentsPostApiResponse"/>?&gt;</returns>
        Task<ICreateCommentApiV1CommentsPostApiResponse?> CreateCommentApiV1CommentsPostOrDefaultAsync(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Comment
        /// </summary>
        /// <remarks>
        /// Delete a comment by ID
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>&gt;</returns>
        Task<IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse> DeleteCommentApiV1CommentsCommentIdDeleteAsync(CommentId1 commentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Comment
        /// </summary>
        /// <remarks>
        /// Delete a comment by ID
        /// </remarks>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>?&gt;</returns>
        Task<IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse?> DeleteCommentApiV1CommentsCommentIdDeleteOrDefaultAsync(CommentId1 commentId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Comment
        /// </summary>
        /// <remarks>
        /// Returns a single comment by ID
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentApiV1CommentsCommentIdGetApiResponse"/>&gt;</returns>
        Task<IGetCommentApiV1CommentsCommentIdGetApiResponse> GetCommentApiV1CommentsCommentIdGetAsync(CommentId? commentId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Comment
        /// </summary>
        /// <remarks>
        /// Returns a single comment by ID
        /// </remarks>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentApiV1CommentsCommentIdGetApiResponse"/>?&gt;</returns>
        Task<IGetCommentApiV1CommentsCommentIdGetApiResponse?> GetCommentApiV1CommentsCommentIdGetOrDefaultAsync(CommentId? commentId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Comments
        /// </summary>
        /// <remarks>
        /// Returns a list of all comments for a given &#x60;task_id&#x60; or &#x60;project_id&#x60;.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectId"> (optional)</param>
        /// <param name="taskId"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentsApiV1CommentsGetApiResponse"/>&gt;</returns>
        Task<IGetCommentsApiV1CommentsGetApiResponse> GetCommentsApiV1CommentsGetAsync(Option<ProjectId1?> projectId = default, Option<TaskId?> taskId = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Comments
        /// </summary>
        /// <remarks>
        /// Returns a list of all comments for a given &#x60;task_id&#x60; or &#x60;project_id&#x60;.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </remarks>
        /// <param name="projectId"> (optional)</param>
        /// <param name="taskId"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentsApiV1CommentsGetApiResponse"/>?&gt;</returns>
        Task<IGetCommentsApiV1CommentsGetApiResponse?> GetCommentsApiV1CommentsGetOrDefaultAsync(Option<ProjectId1?> projectId = default, Option<TaskId?> taskId = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Comment
        /// </summary>
        /// <remarks>
        /// Update a comment by ID and returns its content
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCommentApiV1CommentsCommentIdPostApiResponse"/>&gt;</returns>
        Task<IUpdateCommentApiV1CommentsCommentIdPostApiResponse> UpdateCommentApiV1CommentsCommentIdPostAsync(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Comment
        /// </summary>
        /// <remarks>
        /// Update a comment by ID and returns its content
        /// </remarks>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCommentApiV1CommentsCommentIdPostApiResponse"/>?&gt;</returns>
        Task<IUpdateCommentApiV1CommentsCommentIdPostApiResponse?> UpdateCommentApiV1CommentsCommentIdPostOrDefaultAsync(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateCommentApiV1CommentsPostApiResponse"/>
    /// </summary>
    public interface ICreateCommentApiV1CommentsPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NoteSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>
    /// </summary>
    public interface IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Object?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommentApiV1CommentsCommentIdGetApiResponse"/>
    /// </summary>
    public interface IGetCommentApiV1CommentsCommentIdGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NoteSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetCommentsApiV1CommentsGetApiResponse"/>
    /// </summary>
    public interface IGetCommentsApiV1CommentsGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PaginatedListNoteSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateCommentApiV1CommentsCommentIdPostApiResponse"/>
    /// </summary>
    public interface IUpdateCommentApiV1CommentsCommentIdPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NoteSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class CommentsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateCommentApiV1CommentsPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateCommentApiV1CommentsPost;

        internal void ExecuteOnCreateCommentApiV1CommentsPost(CommentsApi.CreateCommentApiV1CommentsPostApiResponse apiResponse)
        {
            OnCreateCommentApiV1CommentsPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateCommentApiV1CommentsPost(Exception exception)
        {
            OnErrorCreateCommentApiV1CommentsPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteCommentApiV1CommentsCommentIdDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteCommentApiV1CommentsCommentIdDelete;

        internal void ExecuteOnDeleteCommentApiV1CommentsCommentIdDelete(CommentsApi.DeleteCommentApiV1CommentsCommentIdDeleteApiResponse apiResponse)
        {
            OnDeleteCommentApiV1CommentsCommentIdDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteCommentApiV1CommentsCommentIdDelete(Exception exception)
        {
            OnErrorDeleteCommentApiV1CommentsCommentIdDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommentApiV1CommentsCommentIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommentApiV1CommentsCommentIdGet;

        internal void ExecuteOnGetCommentApiV1CommentsCommentIdGet(CommentsApi.GetCommentApiV1CommentsCommentIdGetApiResponse apiResponse)
        {
            OnGetCommentApiV1CommentsCommentIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommentApiV1CommentsCommentIdGet(Exception exception)
        {
            OnErrorGetCommentApiV1CommentsCommentIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCommentsApiV1CommentsGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCommentsApiV1CommentsGet;

        internal void ExecuteOnGetCommentsApiV1CommentsGet(CommentsApi.GetCommentsApiV1CommentsGetApiResponse apiResponse)
        {
            OnGetCommentsApiV1CommentsGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCommentsApiV1CommentsGet(Exception exception)
        {
            OnErrorGetCommentsApiV1CommentsGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateCommentApiV1CommentsCommentIdPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateCommentApiV1CommentsCommentIdPost;

        internal void ExecuteOnUpdateCommentApiV1CommentsCommentIdPost(CommentsApi.UpdateCommentApiV1CommentsCommentIdPostApiResponse apiResponse)
        {
            OnUpdateCommentApiV1CommentsCommentIdPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateCommentApiV1CommentsCommentIdPost(Exception exception)
        {
            OnErrorUpdateCommentApiV1CommentsCommentIdPost?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class CommentsApi : ICommentsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CommentsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public CommentsApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CommentsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CommentsApi(ILogger<CommentsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, CommentsApiEvents commentsApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<CommentsApi>();
            HttpClient = httpClient;
            Events = commentsApiEvents;
        }

        partial void FormatCreateCommentApiV1CommentsPost(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        /// <returns></returns>
        private void ValidateCreateCommentApiV1CommentsPost(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1)
        {
            if (todoistAppsApiRestCommentsBody1 == null)
                throw new ArgumentNullException(nameof(todoistAppsApiRestCommentsBody1));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        private void AfterCreateCommentApiV1CommentsPostDefaultImplementation(ICreateCommentApiV1CommentsPostApiResponse apiResponseLocalVar, TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1)
        {
            bool suppressDefaultLog = false;
            AfterCreateCommentApiV1CommentsPost(ref suppressDefaultLog, apiResponseLocalVar, todoistAppsApiRestCommentsBody1);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        partial void AfterCreateCommentApiV1CommentsPost(ref bool suppressDefaultLog, ICreateCommentApiV1CommentsPostApiResponse apiResponseLocalVar, TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        private void OnErrorCreateCommentApiV1CommentsPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateCommentApiV1CommentsPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, todoistAppsApiRestCommentsBody1);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        partial void OnErrorCreateCommentApiV1CommentsPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1);

        /// <summary>
        /// Create Comment Creates a new comment on a project or task and returns it.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </summary>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCommentApiV1CommentsPostApiResponse"/>&gt;</returns>
        public async Task<ICreateCommentApiV1CommentsPostApiResponse?> CreateCommentApiV1CommentsPostOrDefaultAsync(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateCommentApiV1CommentsPostAsync(todoistAppsApiRestCommentsBody1, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Comment Creates a new comment on a project or task and returns it.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiRestCommentsBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCommentApiV1CommentsPostApiResponse"/>&gt;</returns>
        public async Task<ICreateCommentApiV1CommentsPostApiResponse> CreateCommentApiV1CommentsPostAsync(TodoistAppsApiRestCommentsBody1 todoistAppsApiRestCommentsBody1, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateCommentApiV1CommentsPost(todoistAppsApiRestCommentsBody1);

                FormatCreateCommentApiV1CommentsPost(todoistAppsApiRestCommentsBody1);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/comments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/comments");

                    httpRequestMessageLocalVar.Content = (todoistAppsApiRestCommentsBody1 as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiRestCommentsBody1, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateCommentApiV1CommentsPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateCommentApiV1CommentsPostApiResponse>();

                        CreateCommentApiV1CommentsPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/comments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateCommentApiV1CommentsPostDefaultImplementation(apiResponseLocalVar, todoistAppsApiRestCommentsBody1);

                        Events.ExecuteOnCreateCommentApiV1CommentsPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateCommentApiV1CommentsPostDefaultImplementation(e, "/api/v1/comments", uriBuilderLocalVar.Path, todoistAppsApiRestCommentsBody1);
                Events.ExecuteOnErrorCreateCommentApiV1CommentsPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateCommentApiV1CommentsPostApiResponse"/>
        /// </summary>
        public partial class CreateCommentApiV1CommentsPostApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateCommentApiV1CommentsPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateCommentApiV1CommentsPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateCommentApiV1CommentsPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateCommentApiV1CommentsPostApiResponse(ILogger<CreateCommentApiV1CommentsPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NoteSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NoteSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NoteSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteCommentApiV1CommentsCommentIdDelete(CommentId1 commentId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="commentId"></param>
        /// <returns></returns>
        private void ValidateDeleteCommentApiV1CommentsCommentIdDelete(CommentId1 commentId)
        {
            if (commentId == null)
                throw new ArgumentNullException(nameof(commentId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        private void AfterDeleteCommentApiV1CommentsCommentIdDeleteDefaultImplementation(IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse apiResponseLocalVar, CommentId1 commentId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteCommentApiV1CommentsCommentIdDelete(ref suppressDefaultLog, apiResponseLocalVar, commentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        partial void AfterDeleteCommentApiV1CommentsCommentIdDelete(ref bool suppressDefaultLog, IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse apiResponseLocalVar, CommentId1 commentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        private void OnErrorDeleteCommentApiV1CommentsCommentIdDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId1 commentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteCommentApiV1CommentsCommentIdDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, commentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        partial void OnErrorDeleteCommentApiV1CommentsCommentIdDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId1 commentId);

        /// <summary>
        /// Delete Comment Delete a comment by ID
        /// </summary>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse?> DeleteCommentApiV1CommentsCommentIdDeleteOrDefaultAsync(CommentId1 commentId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteCommentApiV1CommentsCommentIdDeleteAsync(commentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Comment Delete a comment by ID
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse> DeleteCommentApiV1CommentsCommentIdDeleteAsync(CommentId1 commentId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteCommentApiV1CommentsCommentIdDelete(commentId);

                FormatDeleteCommentApiV1CommentsCommentIdDelete(commentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/comments/{comment_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/comments/{comment_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcomment_id%7D", Uri.EscapeDataString(commentId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteCommentApiV1CommentsCommentIdDeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteCommentApiV1CommentsCommentIdDeleteApiResponse>();

                        DeleteCommentApiV1CommentsCommentIdDeleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/comments/{comment_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteCommentApiV1CommentsCommentIdDeleteDefaultImplementation(apiResponseLocalVar, commentId);

                        Events.ExecuteOnDeleteCommentApiV1CommentsCommentIdDelete(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteCommentApiV1CommentsCommentIdDeleteDefaultImplementation(e, "/api/v1/comments/{comment_id}", uriBuilderLocalVar.Path, commentId);
                Events.ExecuteOnErrorDeleteCommentApiV1CommentsCommentIdDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>
        /// </summary>
        public partial class DeleteCommentApiV1CommentsCommentIdDeleteApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteCommentApiV1CommentsCommentIdDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteCommentApiV1CommentsCommentIdDeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteCommentApiV1CommentsCommentIdDeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteCommentApiV1CommentsCommentIdDeleteApiResponse(ILogger<DeleteCommentApiV1CommentsCommentIdDeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommentApiV1CommentsCommentIdGet(CommentId? commentId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        private void AfterGetCommentApiV1CommentsCommentIdGetDefaultImplementation(IGetCommentApiV1CommentsCommentIdGetApiResponse apiResponseLocalVar, CommentId? commentId)
        {
            bool suppressDefaultLog = false;
            AfterGetCommentApiV1CommentsCommentIdGet(ref suppressDefaultLog, apiResponseLocalVar, commentId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        partial void AfterGetCommentApiV1CommentsCommentIdGet(ref bool suppressDefaultLog, IGetCommentApiV1CommentsCommentIdGetApiResponse apiResponseLocalVar, CommentId? commentId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        private void OnErrorGetCommentApiV1CommentsCommentIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId? commentId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommentApiV1CommentsCommentIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, commentId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        partial void OnErrorGetCommentApiV1CommentsCommentIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId? commentId);

        /// <summary>
        /// Get Comment Returns a single comment by ID
        /// </summary>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentApiV1CommentsCommentIdGetApiResponse"/>&gt;</returns>
        public async Task<IGetCommentApiV1CommentsCommentIdGetApiResponse?> GetCommentApiV1CommentsCommentIdGetOrDefaultAsync(CommentId? commentId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommentApiV1CommentsCommentIdGetAsync(commentId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Comment Returns a single comment by ID
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentApiV1CommentsCommentIdGetApiResponse"/>&gt;</returns>
        public async Task<IGetCommentApiV1CommentsCommentIdGetApiResponse> GetCommentApiV1CommentsCommentIdGetAsync(CommentId? commentId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetCommentApiV1CommentsCommentIdGet(commentId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/comments/{comment_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/comments/{comment_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcomment_id%7D", Uri.EscapeDataString(commentId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommentApiV1CommentsCommentIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommentApiV1CommentsCommentIdGetApiResponse>();

                        GetCommentApiV1CommentsCommentIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/comments/{comment_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommentApiV1CommentsCommentIdGetDefaultImplementation(apiResponseLocalVar, commentId);

                        Events.ExecuteOnGetCommentApiV1CommentsCommentIdGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommentApiV1CommentsCommentIdGetDefaultImplementation(e, "/api/v1/comments/{comment_id}", uriBuilderLocalVar.Path, commentId);
                Events.ExecuteOnErrorGetCommentApiV1CommentsCommentIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommentApiV1CommentsCommentIdGetApiResponse"/>
        /// </summary>
        public partial class GetCommentApiV1CommentsCommentIdGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetCommentApiV1CommentsCommentIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommentApiV1CommentsCommentIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommentApiV1CommentsCommentIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommentApiV1CommentsCommentIdGetApiResponse(ILogger<GetCommentApiV1CommentsCommentIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NoteSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NoteSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NoteSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCommentsApiV1CommentsGet(Option<ProjectId1?> projectId, Option<TaskId?> taskId, ref Option<string?> cursor, ref Option<int> limit, ref Option<string?> publicKey);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="taskId"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        private void AfterGetCommentsApiV1CommentsGetDefaultImplementation(IGetCommentsApiV1CommentsGetApiResponse apiResponseLocalVar, Option<ProjectId1?> projectId, Option<TaskId?> taskId, Option<string?> cursor, Option<int> limit, Option<string?> publicKey)
        {
            bool suppressDefaultLog = false;
            AfterGetCommentsApiV1CommentsGet(ref suppressDefaultLog, apiResponseLocalVar, projectId, taskId, cursor, limit, publicKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="taskId"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        partial void AfterGetCommentsApiV1CommentsGet(ref bool suppressDefaultLog, IGetCommentsApiV1CommentsGetApiResponse apiResponseLocalVar, Option<ProjectId1?> projectId, Option<TaskId?> taskId, Option<string?> cursor, Option<int> limit, Option<string?> publicKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="taskId"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        private void OnErrorGetCommentsApiV1CommentsGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ProjectId1?> projectId, Option<TaskId?> taskId, Option<string?> cursor, Option<int> limit, Option<string?> publicKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCommentsApiV1CommentsGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, projectId, taskId, cursor, limit, publicKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="taskId"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        partial void OnErrorGetCommentsApiV1CommentsGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ProjectId1?> projectId, Option<TaskId?> taskId, Option<string?> cursor, Option<int> limit, Option<string?> publicKey);

        /// <summary>
        /// Get Comments Returns a list of all comments for a given &#x60;task_id&#x60; or &#x60;project_id&#x60;.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </summary>
        /// <param name="projectId"> (optional)</param>
        /// <param name="taskId"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentsApiV1CommentsGetApiResponse"/>&gt;</returns>
        public async Task<IGetCommentsApiV1CommentsGetApiResponse?> GetCommentsApiV1CommentsGetOrDefaultAsync(Option<ProjectId1?> projectId = default, Option<TaskId?> taskId = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCommentsApiV1CommentsGetAsync(projectId, taskId, cursor, limit, publicKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Comments Returns a list of all comments for a given &#x60;task_id&#x60; or &#x60;project_id&#x60;.  One of &#x60;task_id&#x60; or &#x60;project_id&#x60; arguments is required.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectId"> (optional)</param>
        /// <param name="taskId"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCommentsApiV1CommentsGetApiResponse"/>&gt;</returns>
        public async Task<IGetCommentsApiV1CommentsGetApiResponse> GetCommentsApiV1CommentsGetAsync(Option<ProjectId1?> projectId = default, Option<TaskId?> taskId = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetCommentsApiV1CommentsGet(projectId, taskId, ref cursor, ref limit, ref publicKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/comments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/comments");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (projectId.IsSet)
                        parseQueryStringLocalVar["project_id"] = ClientUtils.ParameterToString(projectId.Value);

                    if (taskId.IsSet)
                        parseQueryStringLocalVar["task_id"] = ClientUtils.ParameterToString(taskId.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (publicKey.IsSet)
                        parseQueryStringLocalVar["public_key"] = ClientUtils.ParameterToString(publicKey.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCommentsApiV1CommentsGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCommentsApiV1CommentsGetApiResponse>();

                        GetCommentsApiV1CommentsGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/comments", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCommentsApiV1CommentsGetDefaultImplementation(apiResponseLocalVar, projectId, taskId, cursor, limit, publicKey);

                        Events.ExecuteOnGetCommentsApiV1CommentsGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCommentsApiV1CommentsGetDefaultImplementation(e, "/api/v1/comments", uriBuilderLocalVar.Path, projectId, taskId, cursor, limit, publicKey);
                Events.ExecuteOnErrorGetCommentsApiV1CommentsGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCommentsApiV1CommentsGetApiResponse"/>
        /// </summary>
        public partial class GetCommentsApiV1CommentsGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetCommentsApiV1CommentsGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCommentsApiV1CommentsGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCommentsApiV1CommentsGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCommentsApiV1CommentsGetApiResponse(ILogger<GetCommentsApiV1CommentsGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PaginatedListNoteSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PaginatedListNoteSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PaginatedListNoteSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateCommentApiV1CommentsCommentIdPost(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        /// <returns></returns>
        private void ValidateUpdateCommentApiV1CommentsCommentIdPost(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2)
        {
            if (commentId == null)
                throw new ArgumentNullException(nameof(commentId));

            if (todoistAppsApiRestCommentsBody2 == null)
                throw new ArgumentNullException(nameof(todoistAppsApiRestCommentsBody2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        private void AfterUpdateCommentApiV1CommentsCommentIdPostDefaultImplementation(IUpdateCommentApiV1CommentsCommentIdPostApiResponse apiResponseLocalVar, CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2)
        {
            bool suppressDefaultLog = false;
            AfterUpdateCommentApiV1CommentsCommentIdPost(ref suppressDefaultLog, apiResponseLocalVar, commentId, todoistAppsApiRestCommentsBody2);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        partial void AfterUpdateCommentApiV1CommentsCommentIdPost(ref bool suppressDefaultLog, IUpdateCommentApiV1CommentsCommentIdPostApiResponse apiResponseLocalVar, CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        private void OnErrorUpdateCommentApiV1CommentsCommentIdPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateCommentApiV1CommentsCommentIdPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, commentId, todoistAppsApiRestCommentsBody2);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        partial void OnErrorUpdateCommentApiV1CommentsCommentIdPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2);

        /// <summary>
        /// Update Comment Update a comment by ID and returns its content
        /// </summary>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCommentApiV1CommentsCommentIdPostApiResponse"/>&gt;</returns>
        public async Task<IUpdateCommentApiV1CommentsCommentIdPostApiResponse?> UpdateCommentApiV1CommentsCommentIdPostOrDefaultAsync(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateCommentApiV1CommentsCommentIdPostAsync(commentId, todoistAppsApiRestCommentsBody2, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Comment Update a comment by ID and returns its content
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="commentId"></param>
        /// <param name="todoistAppsApiRestCommentsBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCommentApiV1CommentsCommentIdPostApiResponse"/>&gt;</returns>
        public async Task<IUpdateCommentApiV1CommentsCommentIdPostApiResponse> UpdateCommentApiV1CommentsCommentIdPostAsync(CommentId1 commentId, TodoistAppsApiRestCommentsBody2 todoistAppsApiRestCommentsBody2, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateCommentApiV1CommentsCommentIdPost(commentId, todoistAppsApiRestCommentsBody2);

                FormatUpdateCommentApiV1CommentsCommentIdPost(commentId, todoistAppsApiRestCommentsBody2);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/comments/{comment_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/comments/{comment_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bcomment_id%7D", Uri.EscapeDataString(commentId.ToString()));

                    httpRequestMessageLocalVar.Content = (todoistAppsApiRestCommentsBody2 as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiRestCommentsBody2, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateCommentApiV1CommentsCommentIdPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateCommentApiV1CommentsCommentIdPostApiResponse>();

                        UpdateCommentApiV1CommentsCommentIdPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/comments/{comment_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateCommentApiV1CommentsCommentIdPostDefaultImplementation(apiResponseLocalVar, commentId, todoistAppsApiRestCommentsBody2);

                        Events.ExecuteOnUpdateCommentApiV1CommentsCommentIdPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateCommentApiV1CommentsCommentIdPostDefaultImplementation(e, "/api/v1/comments/{comment_id}", uriBuilderLocalVar.Path, commentId, todoistAppsApiRestCommentsBody2);
                Events.ExecuteOnErrorUpdateCommentApiV1CommentsCommentIdPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateCommentApiV1CommentsCommentIdPostApiResponse"/>
        /// </summary>
        public partial class UpdateCommentApiV1CommentsCommentIdPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateCommentApiV1CommentsCommentIdPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateCommentApiV1CommentsCommentIdPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateCommentApiV1CommentsCommentIdPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCommentApiV1CommentsCommentIdPostApiResponse(ILogger<UpdateCommentApiV1CommentsCommentIdPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NoteSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NoteSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NoteSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}

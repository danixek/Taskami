// <auto-generated>
/*
 * Todoist API
 *
 * # Developing with Todoist  Thanks for your interest in developing apps with Todoist. In this section we will provide an overview of the API we offer and cover some common topics for application development using them.  You can use our API for free, but depending on your Todoist account plan (or that of the authenticated user), some features may be restricted.  Please consider subscribing to the [Todoist API mailing list](https://groups.google.com/a/doist.com/g/todoist-api) to get important updates.  ## Our API  Our API uses an approach that should be familiar to anyone with experience calling [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) APIs.  We also have a special endpoint called `/sync`, which is used by our first-party clients to keep the data updated locally without having to make many separate requests to the API. Anyone can use it, and some actions will only be available via `/sync`. The format is unconventional compared to current API standards, but it is our main driver for first-party apps.  ## Our SDKs  Our Python and JavaScript SDKs streamline working with the Todoist API, and can be installed from the main package registries for each ecosystem.  For instructions, examples, and reference documentation, visit their pages:  - [Todoist Python SDK](https://doist.github.io/todoist-api-python/) - [Todoist TypeScript SDK](https://doist.github.io/todoist-api-typescript/)  ## Pagination  Paginated endpoints are marked by having the `next_cursor` attribute in the response.  When a response comes back with `next_cursor: null`, it means the endpoint is paginated but there are no more pages to request data from.  If the cursor is `non-null`, there are more objects to return, and a new request is necessary to get the next page.  The `next_cursor` contains an _opaque_ string that shouldn't be modified in any way. It should be sent **as-is** in the `cursor` parameter along with the same parameters used in the previous request.  ## Integrations  Integrations can be created and updated [here](https://app.todoist.com/app/settings/integrations/app-management).  Once done, they can also be submitted for evaluation and inclusion in [our official integrations list](https://www.todoist.com/integrations). This not only serves as an opportunity to market your integration to our audience, but will also serve as a way to help users get set up and familiar with your app quickly.  To get your integration evaluated, please submit it via [this page](https://doist.typeform.com/to/Vvq7kNcl?typeform-source=todoist.com/api/v1/docs).  Lost? Reach out to us at [submissions@doist.com](mailto:submissions@doist.com) anytime. 
 *
 * The version of the OpenAPI document: 1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ITasksApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        TasksApiEvents Events { get; }

        /// <summary>
        /// Close Task
        /// </summary>
        /// <remarks>
        /// Closes a task.  The command performs in the same way as our official clients:  Regular tasks are marked complete and moved to history, along with their subtasks. Tasks with [recurring due dates](https://todoist.com/help/articles/introduction-to-recurring-dates-YUYVJJAV) will be scheduled to their next occurrence.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICloseTaskApiV1TasksTaskIdClosePostApiResponse"/>&gt;</returns>
        Task<ICloseTaskApiV1TasksTaskIdClosePostApiResponse> CloseTaskApiV1TasksTaskIdClosePostAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Close Task
        /// </summary>
        /// <remarks>
        /// Closes a task.  The command performs in the same way as our official clients:  Regular tasks are marked complete and moved to history, along with their subtasks. Tasks with [recurring due dates](https://todoist.com/help/articles/introduction-to-recurring-dates-YUYVJJAV) will be scheduled to their next occurrence.
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICloseTaskApiV1TasksTaskIdClosePostApiResponse"/>?&gt;</returns>
        Task<ICloseTaskApiV1TasksTaskIdClosePostApiResponse?> CloseTaskApiV1TasksTaskIdClosePostOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiV1TasksPostApiResponse"/>&gt;</returns>
        Task<ICreateTaskApiV1TasksPostApiResponse> CreateTaskApiV1TasksPostAsync(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiV1TasksPostApiResponse"/>?&gt;</returns>
        Task<ICreateTaskApiV1TasksPostApiResponse?> CreateTaskApiV1TasksPostOrDefaultAsync(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>&gt;</returns>
        Task<IDeleteTaskApiV1TasksTaskIdDeleteApiResponse> DeleteTaskApiV1TasksTaskIdDeleteAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>?&gt;</returns>
        Task<IDeleteTaskApiV1TasksTaskIdDeleteApiResponse?> DeleteTaskApiV1TasksTaskIdDeleteOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Task
        /// </summary>
        /// <remarks>
        /// Returns a single active (non-completed) task by ID
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskApiV1TasksTaskIdGetApiResponse"/>&gt;</returns>
        Task<IGetTaskApiV1TasksTaskIdGetApiResponse> GetTaskApiV1TasksTaskIdGetAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Task
        /// </summary>
        /// <remarks>
        /// Returns a single active (non-completed) task by ID
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskApiV1TasksTaskIdGetApiResponse"/>?&gt;</returns>
        Task<IGetTaskApiV1TasksTaskIdGetApiResponse?> GetTaskApiV1TasksTaskIdGetOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tasks
        /// </summary>
        /// <remarks>
        /// Returns a paginated list containing all active tasks
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="label"> (optional)</param>
        /// <param name="ids"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksApiV1TasksGetApiResponse"/>&gt;</returns>
        Task<IGetTasksApiV1TasksGetApiResponse> GetTasksApiV1TasksGetAsync(Option<ProjectId2?> projectId = default, Option<SectionId?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> label = default, Option<string?> ids = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tasks
        /// </summary>
        /// <remarks>
        /// Returns a paginated list containing all active tasks
        /// </remarks>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="label"> (optional)</param>
        /// <param name="ids"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksApiV1TasksGetApiResponse"/>?&gt;</returns>
        Task<IGetTasksApiV1TasksGetApiResponse?> GetTasksApiV1TasksGetOrDefaultAsync(Option<ProjectId2?> projectId = default, Option<SectionId?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> label = default, Option<string?> ids = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tasks By Filter
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="query"></param>
        /// <param name="lang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksByFilterApiV1TasksFilterGetApiResponse"/>&gt;</returns>
        Task<IGetTasksByFilterApiV1TasksFilterGetApiResponse> GetTasksByFilterApiV1TasksFilterGetAsync(string query, Option<string?> lang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tasks By Filter
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="query"></param>
        /// <param name="lang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksByFilterApiV1TasksFilterGetApiResponse"/>?&gt;</returns>
        Task<IGetTasksByFilterApiV1TasksFilterGetApiResponse?> GetTasksByFilterApiV1TasksFilterGetOrDefaultAsync(string query, Option<string?> lang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Move Task
        /// </summary>
        /// <remarks>
        /// Moves task to another project, section or parent.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMoveTaskApiV1TasksTaskIdMovePostApiResponse"/>&gt;</returns>
        Task<IMoveTaskApiV1TasksTaskIdMovePostApiResponse> MoveTaskApiV1TasksTaskIdMovePostAsync(string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Move Task
        /// </summary>
        /// <remarks>
        /// Moves task to another project, section or parent.
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMoveTaskApiV1TasksTaskIdMovePostApiResponse"/>?&gt;</returns>
        Task<IMoveTaskApiV1TasksTaskIdMovePostApiResponse?> MoveTaskApiV1TasksTaskIdMovePostOrDefaultAsync(string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Quick Add
        /// </summary>
        /// <remarks>
        /// Add a new task using the Quick Add implementation similar to that used in the official clients
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IQuickAddApiV1TasksQuickPostApiResponse"/>&gt;</returns>
        Task<IQuickAddApiV1TasksQuickPostApiResponse> QuickAddApiV1TasksQuickPostAsync(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Quick Add
        /// </summary>
        /// <remarks>
        /// Add a new task using the Quick Add implementation similar to that used in the official clients
        /// </remarks>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IQuickAddApiV1TasksQuickPostApiResponse"/>?&gt;</returns>
        Task<IQuickAddApiV1TasksQuickPostApiResponse?> QuickAddApiV1TasksQuickPostOrDefaultAsync(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reopen Task
        /// </summary>
        /// <remarks>
        /// Reopens a task.  Any ancestor tasks or sections will also be marked as uncomplete and restored from history.  The reinstated tasks and sections will appear at the end of the list within their parent, after any previously active tasks.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>&gt;</returns>
        Task<IReopenTaskApiV1TasksTaskIdReopenPostApiResponse> ReopenTaskApiV1TasksTaskIdReopenPostAsync(TaskId1 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reopen Task
        /// </summary>
        /// <remarks>
        /// Reopens a task.  Any ancestor tasks or sections will also be marked as uncomplete and restored from history.  The reinstated tasks and sections will appear at the end of the list within their parent, after any previously active tasks.
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>?&gt;</returns>
        Task<IReopenTaskApiV1TasksTaskIdReopenPostApiResponse?> ReopenTaskApiV1TasksTaskIdReopenPostOrDefaultAsync(TaskId1 taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Tasks Completed By Completion Date
        /// </summary>
        /// <remarks>
        /// Retrieves a list of completed tasks strictly limited by the specified completion date range (up to 3 months).  It can retrieve completed items:  - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>&gt;</returns>
        Task<ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse> TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Tasks Completed By Completion Date
        /// </summary>
        /// <remarks>
        /// Retrieves a list of completed tasks strictly limited by the specified completion date range (up to 3 months).  It can retrieve completed items:  - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </remarks>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>?&gt;</returns>
        Task<ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse?> TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetOrDefaultAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Tasks Completed By Due Date
        /// </summary>
        /// <remarks>
        /// Retrieves a list of completed items strictly limited by the specified due date range (up to 6 weeks).  It can retrieve completed items:  - From within a project, section, or parent item - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>&gt;</returns>
        Task<ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse> TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Tasks Completed By Due Date
        /// </summary>
        /// <remarks>
        /// Retrieves a list of completed items strictly limited by the specified due date range (up to 6 weeks).  It can retrieve completed items:  - From within a project, section, or parent item - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </remarks>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>?&gt;</returns>
        Task<ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse?> TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetOrDefaultAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiV1TasksTaskIdPostApiResponse"/>&gt;</returns>
        Task<IUpdateTaskApiV1TasksTaskIdPostApiResponse> UpdateTaskApiV1TasksTaskIdPostAsync(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiV1TasksTaskIdPostApiResponse"/>?&gt;</returns>
        Task<IUpdateTaskApiV1TasksTaskIdPostApiResponse?> UpdateTaskApiV1TasksTaskIdPostOrDefaultAsync(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICloseTaskApiV1TasksTaskIdClosePostApiResponse"/>
    /// </summary>
    public interface ICloseTaskApiV1TasksTaskIdClosePostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Object?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ICreateTaskApiV1TasksPostApiResponse"/>
    /// </summary>
    public interface ICreateTaskApiV1TasksPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>
    /// </summary>
    public interface IDeleteTaskApiV1TasksTaskIdDeleteApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Object?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetTaskApiV1TasksTaskIdGetApiResponse"/>
    /// </summary>
    public interface IGetTaskApiV1TasksTaskIdGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetTasksApiV1TasksGetApiResponse"/>
    /// </summary>
    public interface IGetTasksApiV1TasksGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PaginatedListItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetTasksByFilterApiV1TasksFilterGetApiResponse"/>
    /// </summary>
    public interface IGetTasksByFilterApiV1TasksFilterGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PaginatedListItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IMoveTaskApiV1TasksTaskIdMovePostApiResponse"/>
    /// </summary>
    public interface IMoveTaskApiV1TasksTaskIdMovePostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IQuickAddApiV1TasksQuickPostApiResponse"/>
    /// </summary>
    public interface IQuickAddApiV1TasksQuickPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Dictionary<string, Object>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>
    /// </summary>
    public interface IReopenTaskApiV1TasksTaskIdReopenPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Object?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>
    /// </summary>
    public interface ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TasksCompletedDateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>
    /// </summary>
    public interface ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TasksCompletedDateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateTaskApiV1TasksTaskIdPostApiResponse"/>
    /// </summary>
    public interface IUpdateTaskApiV1TasksTaskIdPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ItemSyncView?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class TasksApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCloseTaskApiV1TasksTaskIdClosePost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCloseTaskApiV1TasksTaskIdClosePost;

        internal void ExecuteOnCloseTaskApiV1TasksTaskIdClosePost(TasksApi.CloseTaskApiV1TasksTaskIdClosePostApiResponse apiResponse)
        {
            OnCloseTaskApiV1TasksTaskIdClosePost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCloseTaskApiV1TasksTaskIdClosePost(Exception exception)
        {
            OnErrorCloseTaskApiV1TasksTaskIdClosePost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateTaskApiV1TasksPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateTaskApiV1TasksPost;

        internal void ExecuteOnCreateTaskApiV1TasksPost(TasksApi.CreateTaskApiV1TasksPostApiResponse apiResponse)
        {
            OnCreateTaskApiV1TasksPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateTaskApiV1TasksPost(Exception exception)
        {
            OnErrorCreateTaskApiV1TasksPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteTaskApiV1TasksTaskIdDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteTaskApiV1TasksTaskIdDelete;

        internal void ExecuteOnDeleteTaskApiV1TasksTaskIdDelete(TasksApi.DeleteTaskApiV1TasksTaskIdDeleteApiResponse apiResponse)
        {
            OnDeleteTaskApiV1TasksTaskIdDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteTaskApiV1TasksTaskIdDelete(Exception exception)
        {
            OnErrorDeleteTaskApiV1TasksTaskIdDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTaskApiV1TasksTaskIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTaskApiV1TasksTaskIdGet;

        internal void ExecuteOnGetTaskApiV1TasksTaskIdGet(TasksApi.GetTaskApiV1TasksTaskIdGetApiResponse apiResponse)
        {
            OnGetTaskApiV1TasksTaskIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTaskApiV1TasksTaskIdGet(Exception exception)
        {
            OnErrorGetTaskApiV1TasksTaskIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTasksApiV1TasksGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTasksApiV1TasksGet;

        internal void ExecuteOnGetTasksApiV1TasksGet(TasksApi.GetTasksApiV1TasksGetApiResponse apiResponse)
        {
            OnGetTasksApiV1TasksGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTasksApiV1TasksGet(Exception exception)
        {
            OnErrorGetTasksApiV1TasksGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTasksByFilterApiV1TasksFilterGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTasksByFilterApiV1TasksFilterGet;

        internal void ExecuteOnGetTasksByFilterApiV1TasksFilterGet(TasksApi.GetTasksByFilterApiV1TasksFilterGetApiResponse apiResponse)
        {
            OnGetTasksByFilterApiV1TasksFilterGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTasksByFilterApiV1TasksFilterGet(Exception exception)
        {
            OnErrorGetTasksByFilterApiV1TasksFilterGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMoveTaskApiV1TasksTaskIdMovePost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMoveTaskApiV1TasksTaskIdMovePost;

        internal void ExecuteOnMoveTaskApiV1TasksTaskIdMovePost(TasksApi.MoveTaskApiV1TasksTaskIdMovePostApiResponse apiResponse)
        {
            OnMoveTaskApiV1TasksTaskIdMovePost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMoveTaskApiV1TasksTaskIdMovePost(Exception exception)
        {
            OnErrorMoveTaskApiV1TasksTaskIdMovePost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnQuickAddApiV1TasksQuickPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorQuickAddApiV1TasksQuickPost;

        internal void ExecuteOnQuickAddApiV1TasksQuickPost(TasksApi.QuickAddApiV1TasksQuickPostApiResponse apiResponse)
        {
            OnQuickAddApiV1TasksQuickPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorQuickAddApiV1TasksQuickPost(Exception exception)
        {
            OnErrorQuickAddApiV1TasksQuickPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReopenTaskApiV1TasksTaskIdReopenPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReopenTaskApiV1TasksTaskIdReopenPost;

        internal void ExecuteOnReopenTaskApiV1TasksTaskIdReopenPost(TasksApi.ReopenTaskApiV1TasksTaskIdReopenPostApiResponse apiResponse)
        {
            OnReopenTaskApiV1TasksTaskIdReopenPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReopenTaskApiV1TasksTaskIdReopenPost(Exception exception)
        {
            OnErrorReopenTaskApiV1TasksTaskIdReopenPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet;

        internal void ExecuteOnTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(TasksApi.TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse apiResponse)
        {
            OnTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(Exception exception)
        {
            OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet;

        internal void ExecuteOnTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(TasksApi.TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse apiResponse)
        {
            OnTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(Exception exception)
        {
            OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateTaskApiV1TasksTaskIdPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateTaskApiV1TasksTaskIdPost;

        internal void ExecuteOnUpdateTaskApiV1TasksTaskIdPost(TasksApi.UpdateTaskApiV1TasksTaskIdPostApiResponse apiResponse)
        {
            OnUpdateTaskApiV1TasksTaskIdPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateTaskApiV1TasksTaskIdPost(Exception exception)
        {
            OnErrorUpdateTaskApiV1TasksTaskIdPost?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class TasksApi : ITasksApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<TasksApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public TasksApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TasksApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TasksApi(ILogger<TasksApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, TasksApiEvents tasksApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<TasksApi>();
            HttpClient = httpClient;
            Events = tasksApiEvents;
        }

        partial void FormatCloseTaskApiV1TasksTaskIdClosePost(TaskId2 taskId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <returns></returns>
        private void ValidateCloseTaskApiV1TasksTaskIdClosePost(TaskId2 taskId)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        private void AfterCloseTaskApiV1TasksTaskIdClosePostDefaultImplementation(ICloseTaskApiV1TasksTaskIdClosePostApiResponse apiResponseLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLog = false;
            AfterCloseTaskApiV1TasksTaskIdClosePost(ref suppressDefaultLog, apiResponseLocalVar, taskId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        partial void AfterCloseTaskApiV1TasksTaskIdClosePost(ref bool suppressDefaultLog, ICloseTaskApiV1TasksTaskIdClosePostApiResponse apiResponseLocalVar, TaskId2 taskId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        private void OnErrorCloseTaskApiV1TasksTaskIdClosePostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCloseTaskApiV1TasksTaskIdClosePost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        partial void OnErrorCloseTaskApiV1TasksTaskIdClosePost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId);

        /// <summary>
        /// Close Task Closes a task.  The command performs in the same way as our official clients:  Regular tasks are marked complete and moved to history, along with their subtasks. Tasks with [recurring due dates](https://todoist.com/help/articles/introduction-to-recurring-dates-YUYVJJAV) will be scheduled to their next occurrence.
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICloseTaskApiV1TasksTaskIdClosePostApiResponse"/>&gt;</returns>
        public async Task<ICloseTaskApiV1TasksTaskIdClosePostApiResponse?> CloseTaskApiV1TasksTaskIdClosePostOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CloseTaskApiV1TasksTaskIdClosePostAsync(taskId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Close Task Closes a task.  The command performs in the same way as our official clients:  Regular tasks are marked complete and moved to history, along with their subtasks. Tasks with [recurring due dates](https://todoist.com/help/articles/introduction-to-recurring-dates-YUYVJJAV) will be scheduled to their next occurrence.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICloseTaskApiV1TasksTaskIdClosePostApiResponse"/>&gt;</returns>
        public async Task<ICloseTaskApiV1TasksTaskIdClosePostApiResponse> CloseTaskApiV1TasksTaskIdClosePostAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCloseTaskApiV1TasksTaskIdClosePost(taskId);

                FormatCloseTaskApiV1TasksTaskIdClosePost(taskId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}/close"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}/close");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CloseTaskApiV1TasksTaskIdClosePostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CloseTaskApiV1TasksTaskIdClosePostApiResponse>();

                        CloseTaskApiV1TasksTaskIdClosePostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}/close", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCloseTaskApiV1TasksTaskIdClosePostDefaultImplementation(apiResponseLocalVar, taskId);

                        Events.ExecuteOnCloseTaskApiV1TasksTaskIdClosePost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCloseTaskApiV1TasksTaskIdClosePostDefaultImplementation(e, "/api/v1/tasks/{task_id}/close", uriBuilderLocalVar.Path, taskId);
                Events.ExecuteOnErrorCloseTaskApiV1TasksTaskIdClosePost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CloseTaskApiV1TasksTaskIdClosePostApiResponse"/>
        /// </summary>
        public partial class CloseTaskApiV1TasksTaskIdClosePostApiResponse : Org.OpenAPITools.Client.ApiResponse, ICloseTaskApiV1TasksTaskIdClosePostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CloseTaskApiV1TasksTaskIdClosePostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CloseTaskApiV1TasksTaskIdClosePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CloseTaskApiV1TasksTaskIdClosePostApiResponse(ILogger<CloseTaskApiV1TasksTaskIdClosePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateTaskApiV1TasksPost(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        /// <returns></returns>
        private void ValidateCreateTaskApiV1TasksPost(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1)
        {
            if (todoistAppsApiRestTasksBody1 == null)
                throw new ArgumentNullException(nameof(todoistAppsApiRestTasksBody1));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        private void AfterCreateTaskApiV1TasksPostDefaultImplementation(ICreateTaskApiV1TasksPostApiResponse apiResponseLocalVar, TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1)
        {
            bool suppressDefaultLog = false;
            AfterCreateTaskApiV1TasksPost(ref suppressDefaultLog, apiResponseLocalVar, todoistAppsApiRestTasksBody1);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        partial void AfterCreateTaskApiV1TasksPost(ref bool suppressDefaultLog, ICreateTaskApiV1TasksPostApiResponse apiResponseLocalVar, TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        private void OnErrorCreateTaskApiV1TasksPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateTaskApiV1TasksPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, todoistAppsApiRestTasksBody1);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        partial void OnErrorCreateTaskApiV1TasksPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1);

        /// <summary>
        /// Create Task 
        /// </summary>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiV1TasksPostApiResponse"/>&gt;</returns>
        public async Task<ICreateTaskApiV1TasksPostApiResponse?> CreateTaskApiV1TasksPostOrDefaultAsync(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateTaskApiV1TasksPostAsync(todoistAppsApiRestTasksBody1, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiRestTasksBody1"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiV1TasksPostApiResponse"/>&gt;</returns>
        public async Task<ICreateTaskApiV1TasksPostApiResponse> CreateTaskApiV1TasksPostAsync(TodoistAppsApiRestTasksBody1 todoistAppsApiRestTasksBody1, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateTaskApiV1TasksPost(todoistAppsApiRestTasksBody1);

                FormatCreateTaskApiV1TasksPost(todoistAppsApiRestTasksBody1);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks");

                    httpRequestMessageLocalVar.Content = (todoistAppsApiRestTasksBody1 as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiRestTasksBody1, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateTaskApiV1TasksPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateTaskApiV1TasksPostApiResponse>();

                        CreateTaskApiV1TasksPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateTaskApiV1TasksPostDefaultImplementation(apiResponseLocalVar, todoistAppsApiRestTasksBody1);

                        Events.ExecuteOnCreateTaskApiV1TasksPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateTaskApiV1TasksPostDefaultImplementation(e, "/api/v1/tasks", uriBuilderLocalVar.Path, todoistAppsApiRestTasksBody1);
                Events.ExecuteOnErrorCreateTaskApiV1TasksPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateTaskApiV1TasksPostApiResponse"/>
        /// </summary>
        public partial class CreateTaskApiV1TasksPostApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateTaskApiV1TasksPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateTaskApiV1TasksPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateTaskApiV1TasksPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTaskApiV1TasksPostApiResponse(ILogger<CreateTaskApiV1TasksPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteTaskApiV1TasksTaskIdDelete(TaskId2 taskId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <returns></returns>
        private void ValidateDeleteTaskApiV1TasksTaskIdDelete(TaskId2 taskId)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        private void AfterDeleteTaskApiV1TasksTaskIdDeleteDefaultImplementation(IDeleteTaskApiV1TasksTaskIdDeleteApiResponse apiResponseLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteTaskApiV1TasksTaskIdDelete(ref suppressDefaultLog, apiResponseLocalVar, taskId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        partial void AfterDeleteTaskApiV1TasksTaskIdDelete(ref bool suppressDefaultLog, IDeleteTaskApiV1TasksTaskIdDeleteApiResponse apiResponseLocalVar, TaskId2 taskId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        private void OnErrorDeleteTaskApiV1TasksTaskIdDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteTaskApiV1TasksTaskIdDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        partial void OnErrorDeleteTaskApiV1TasksTaskIdDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId);

        /// <summary>
        /// Delete Task 
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteTaskApiV1TasksTaskIdDeleteApiResponse?> DeleteTaskApiV1TasksTaskIdDeleteOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteTaskApiV1TasksTaskIdDeleteAsync(taskId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteTaskApiV1TasksTaskIdDeleteApiResponse> DeleteTaskApiV1TasksTaskIdDeleteAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteTaskApiV1TasksTaskIdDelete(taskId);

                FormatDeleteTaskApiV1TasksTaskIdDelete(taskId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteTaskApiV1TasksTaskIdDeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteTaskApiV1TasksTaskIdDeleteApiResponse>();

                        DeleteTaskApiV1TasksTaskIdDeleteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteTaskApiV1TasksTaskIdDeleteDefaultImplementation(apiResponseLocalVar, taskId);

                        Events.ExecuteOnDeleteTaskApiV1TasksTaskIdDelete(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteTaskApiV1TasksTaskIdDeleteDefaultImplementation(e, "/api/v1/tasks/{task_id}", uriBuilderLocalVar.Path, taskId);
                Events.ExecuteOnErrorDeleteTaskApiV1TasksTaskIdDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>
        /// </summary>
        public partial class DeleteTaskApiV1TasksTaskIdDeleteApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteTaskApiV1TasksTaskIdDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteTaskApiV1TasksTaskIdDeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteTaskApiV1TasksTaskIdDeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTaskApiV1TasksTaskIdDeleteApiResponse(ILogger<DeleteTaskApiV1TasksTaskIdDeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTaskApiV1TasksTaskIdGet(TaskId2 taskId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <returns></returns>
        private void ValidateGetTaskApiV1TasksTaskIdGet(TaskId2 taskId)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        private void AfterGetTaskApiV1TasksTaskIdGetDefaultImplementation(IGetTaskApiV1TasksTaskIdGetApiResponse apiResponseLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLog = false;
            AfterGetTaskApiV1TasksTaskIdGet(ref suppressDefaultLog, apiResponseLocalVar, taskId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        partial void AfterGetTaskApiV1TasksTaskIdGet(ref bool suppressDefaultLog, IGetTaskApiV1TasksTaskIdGetApiResponse apiResponseLocalVar, TaskId2 taskId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        private void OnErrorGetTaskApiV1TasksTaskIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTaskApiV1TasksTaskIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        partial void OnErrorGetTaskApiV1TasksTaskIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId);

        /// <summary>
        /// Get Task Returns a single active (non-completed) task by ID
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskApiV1TasksTaskIdGetApiResponse"/>&gt;</returns>
        public async Task<IGetTaskApiV1TasksTaskIdGetApiResponse?> GetTaskApiV1TasksTaskIdGetOrDefaultAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTaskApiV1TasksTaskIdGetAsync(taskId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Task Returns a single active (non-completed) task by ID
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskApiV1TasksTaskIdGetApiResponse"/>&gt;</returns>
        public async Task<IGetTaskApiV1TasksTaskIdGetApiResponse> GetTaskApiV1TasksTaskIdGetAsync(TaskId2 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTaskApiV1TasksTaskIdGet(taskId);

                FormatGetTaskApiV1TasksTaskIdGet(taskId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTaskApiV1TasksTaskIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTaskApiV1TasksTaskIdGetApiResponse>();

                        GetTaskApiV1TasksTaskIdGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTaskApiV1TasksTaskIdGetDefaultImplementation(apiResponseLocalVar, taskId);

                        Events.ExecuteOnGetTaskApiV1TasksTaskIdGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTaskApiV1TasksTaskIdGetDefaultImplementation(e, "/api/v1/tasks/{task_id}", uriBuilderLocalVar.Path, taskId);
                Events.ExecuteOnErrorGetTaskApiV1TasksTaskIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTaskApiV1TasksTaskIdGetApiResponse"/>
        /// </summary>
        public partial class GetTaskApiV1TasksTaskIdGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTaskApiV1TasksTaskIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTaskApiV1TasksTaskIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTaskApiV1TasksTaskIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTaskApiV1TasksTaskIdGetApiResponse(ILogger<GetTaskApiV1TasksTaskIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTasksApiV1TasksGet(Option<ProjectId2?> projectId, Option<SectionId?> sectionId, Option<ParentId?> parentId, ref Option<string?> label, ref Option<string?> ids, ref Option<string?> cursor, ref Option<int> limit);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="label"></param>
        /// <param name="ids"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void AfterGetTasksApiV1TasksGetDefaultImplementation(IGetTasksApiV1TasksGetApiResponse apiResponseLocalVar, Option<ProjectId2?> projectId, Option<SectionId?> sectionId, Option<ParentId?> parentId, Option<string?> label, Option<string?> ids, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterGetTasksApiV1TasksGet(ref suppressDefaultLog, apiResponseLocalVar, projectId, sectionId, parentId, label, ids, cursor, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="label"></param>
        /// <param name="ids"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void AfterGetTasksApiV1TasksGet(ref bool suppressDefaultLog, IGetTasksApiV1TasksGetApiResponse apiResponseLocalVar, Option<ProjectId2?> projectId, Option<SectionId?> sectionId, Option<ParentId?> parentId, Option<string?> label, Option<string?> ids, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="label"></param>
        /// <param name="ids"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void OnErrorGetTasksApiV1TasksGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ProjectId2?> projectId, Option<SectionId?> sectionId, Option<ParentId?> parentId, Option<string?> label, Option<string?> ids, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTasksApiV1TasksGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, projectId, sectionId, parentId, label, ids, cursor, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="label"></param>
        /// <param name="ids"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void OnErrorGetTasksApiV1TasksGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ProjectId2?> projectId, Option<SectionId?> sectionId, Option<ParentId?> parentId, Option<string?> label, Option<string?> ids, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Get Tasks Returns a paginated list containing all active tasks
        /// </summary>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="label"> (optional)</param>
        /// <param name="ids"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksApiV1TasksGetApiResponse"/>&gt;</returns>
        public async Task<IGetTasksApiV1TasksGetApiResponse?> GetTasksApiV1TasksGetOrDefaultAsync(Option<ProjectId2?> projectId = default, Option<SectionId?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> label = default, Option<string?> ids = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTasksApiV1TasksGetAsync(projectId, sectionId, parentId, label, ids, cursor, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Tasks Returns a paginated list containing all active tasks
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="label"> (optional)</param>
        /// <param name="ids"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksApiV1TasksGetApiResponse"/>&gt;</returns>
        public async Task<IGetTasksApiV1TasksGetApiResponse> GetTasksApiV1TasksGetAsync(Option<ProjectId2?> projectId = default, Option<SectionId?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> label = default, Option<string?> ids = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetTasksApiV1TasksGet(projectId, sectionId, parentId, ref label, ref ids, ref cursor, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (projectId.IsSet)
                        parseQueryStringLocalVar["project_id"] = ClientUtils.ParameterToString(projectId.Value);

                    if (sectionId.IsSet)
                        parseQueryStringLocalVar["section_id"] = ClientUtils.ParameterToString(sectionId.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parent_id"] = ClientUtils.ParameterToString(parentId.Value);

                    if (label.IsSet)
                        parseQueryStringLocalVar["label"] = ClientUtils.ParameterToString(label.Value);

                    if (ids.IsSet)
                        parseQueryStringLocalVar["ids"] = ClientUtils.ParameterToString(ids.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTasksApiV1TasksGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTasksApiV1TasksGetApiResponse>();

                        GetTasksApiV1TasksGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTasksApiV1TasksGetDefaultImplementation(apiResponseLocalVar, projectId, sectionId, parentId, label, ids, cursor, limit);

                        Events.ExecuteOnGetTasksApiV1TasksGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTasksApiV1TasksGetDefaultImplementation(e, "/api/v1/tasks", uriBuilderLocalVar.Path, projectId, sectionId, parentId, label, ids, cursor, limit);
                Events.ExecuteOnErrorGetTasksApiV1TasksGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTasksApiV1TasksGetApiResponse"/>
        /// </summary>
        public partial class GetTasksApiV1TasksGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTasksApiV1TasksGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTasksApiV1TasksGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTasksApiV1TasksGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTasksApiV1TasksGetApiResponse(ILogger<GetTasksApiV1TasksGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PaginatedListItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PaginatedListItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PaginatedListItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTasksByFilterApiV1TasksFilterGet(ref string query, ref Option<string?> lang, ref Option<string?> cursor, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="query"></param>
        /// <returns></returns>
        private void ValidateGetTasksByFilterApiV1TasksFilterGet(string query)
        {
            if (query == null)
                throw new ArgumentNullException(nameof(query));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="query"></param>
        /// <param name="lang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void AfterGetTasksByFilterApiV1TasksFilterGetDefaultImplementation(IGetTasksByFilterApiV1TasksFilterGetApiResponse apiResponseLocalVar, string query, Option<string?> lang, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterGetTasksByFilterApiV1TasksFilterGet(ref suppressDefaultLog, apiResponseLocalVar, query, lang, cursor, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="query"></param>
        /// <param name="lang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void AfterGetTasksByFilterApiV1TasksFilterGet(ref bool suppressDefaultLog, IGetTasksByFilterApiV1TasksFilterGetApiResponse apiResponseLocalVar, string query, Option<string?> lang, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="query"></param>
        /// <param name="lang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void OnErrorGetTasksByFilterApiV1TasksFilterGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string query, Option<string?> lang, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTasksByFilterApiV1TasksFilterGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, query, lang, cursor, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="query"></param>
        /// <param name="lang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void OnErrorGetTasksByFilterApiV1TasksFilterGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string query, Option<string?> lang, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Get Tasks By Filter 
        /// </summary>
        /// <param name="query"></param>
        /// <param name="lang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksByFilterApiV1TasksFilterGetApiResponse"/>&gt;</returns>
        public async Task<IGetTasksByFilterApiV1TasksFilterGetApiResponse?> GetTasksByFilterApiV1TasksFilterGetOrDefaultAsync(string query, Option<string?> lang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTasksByFilterApiV1TasksFilterGetAsync(query, lang, cursor, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Tasks By Filter 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="query"></param>
        /// <param name="lang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTasksByFilterApiV1TasksFilterGetApiResponse"/>&gt;</returns>
        public async Task<IGetTasksByFilterApiV1TasksFilterGetApiResponse> GetTasksByFilterApiV1TasksFilterGetAsync(string query, Option<string?> lang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTasksByFilterApiV1TasksFilterGet(query);

                FormatGetTasksByFilterApiV1TasksFilterGet(ref query, ref lang, ref cursor, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/filter"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/filter");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["query"] = ClientUtils.ParameterToString(query);

                    if (lang.IsSet)
                        parseQueryStringLocalVar["lang"] = ClientUtils.ParameterToString(lang.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTasksByFilterApiV1TasksFilterGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTasksByFilterApiV1TasksFilterGetApiResponse>();

                        GetTasksByFilterApiV1TasksFilterGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/filter", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTasksByFilterApiV1TasksFilterGetDefaultImplementation(apiResponseLocalVar, query, lang, cursor, limit);

                        Events.ExecuteOnGetTasksByFilterApiV1TasksFilterGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTasksByFilterApiV1TasksFilterGetDefaultImplementation(e, "/api/v1/tasks/filter", uriBuilderLocalVar.Path, query, lang, cursor, limit);
                Events.ExecuteOnErrorGetTasksByFilterApiV1TasksFilterGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTasksByFilterApiV1TasksFilterGetApiResponse"/>
        /// </summary>
        public partial class GetTasksByFilterApiV1TasksFilterGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTasksByFilterApiV1TasksFilterGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTasksByFilterApiV1TasksFilterGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTasksByFilterApiV1TasksFilterGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTasksByFilterApiV1TasksFilterGetApiResponse(ILogger<GetTasksByFilterApiV1TasksFilterGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PaginatedListItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PaginatedListItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PaginatedListItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMoveTaskApiV1TasksTaskIdMovePost(ref string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        /// <returns></returns>
        private void ValidateMoveTaskApiV1TasksTaskIdMovePost(string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));

            if (todoistAppsApiRestTasksBody2 == null)
                throw new ArgumentNullException(nameof(todoistAppsApiRestTasksBody2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        private void AfterMoveTaskApiV1TasksTaskIdMovePostDefaultImplementation(IMoveTaskApiV1TasksTaskIdMovePostApiResponse apiResponseLocalVar, string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2)
        {
            bool suppressDefaultLog = false;
            AfterMoveTaskApiV1TasksTaskIdMovePost(ref suppressDefaultLog, apiResponseLocalVar, taskId, todoistAppsApiRestTasksBody2);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        partial void AfterMoveTaskApiV1TasksTaskIdMovePost(ref bool suppressDefaultLog, IMoveTaskApiV1TasksTaskIdMovePostApiResponse apiResponseLocalVar, string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        private void OnErrorMoveTaskApiV1TasksTaskIdMovePostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMoveTaskApiV1TasksTaskIdMovePost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId, todoistAppsApiRestTasksBody2);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        partial void OnErrorMoveTaskApiV1TasksTaskIdMovePost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2);

        /// <summary>
        /// Move Task Moves task to another project, section or parent.
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMoveTaskApiV1TasksTaskIdMovePostApiResponse"/>&gt;</returns>
        public async Task<IMoveTaskApiV1TasksTaskIdMovePostApiResponse?> MoveTaskApiV1TasksTaskIdMovePostOrDefaultAsync(string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MoveTaskApiV1TasksTaskIdMovePostAsync(taskId, todoistAppsApiRestTasksBody2, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Move Task Moves task to another project, section or parent.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody2"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMoveTaskApiV1TasksTaskIdMovePostApiResponse"/>&gt;</returns>
        public async Task<IMoveTaskApiV1TasksTaskIdMovePostApiResponse> MoveTaskApiV1TasksTaskIdMovePostAsync(string taskId, TodoistAppsApiRestTasksBody2 todoistAppsApiRestTasksBody2, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateMoveTaskApiV1TasksTaskIdMovePost(taskId, todoistAppsApiRestTasksBody2);

                FormatMoveTaskApiV1TasksTaskIdMovePost(ref taskId, todoistAppsApiRestTasksBody2);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}/move"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}/move");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.Content = (todoistAppsApiRestTasksBody2 as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiRestTasksBody2, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<MoveTaskApiV1TasksTaskIdMovePostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MoveTaskApiV1TasksTaskIdMovePostApiResponse>();

                        MoveTaskApiV1TasksTaskIdMovePostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}/move", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterMoveTaskApiV1TasksTaskIdMovePostDefaultImplementation(apiResponseLocalVar, taskId, todoistAppsApiRestTasksBody2);

                        Events.ExecuteOnMoveTaskApiV1TasksTaskIdMovePost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMoveTaskApiV1TasksTaskIdMovePostDefaultImplementation(e, "/api/v1/tasks/{task_id}/move", uriBuilderLocalVar.Path, taskId, todoistAppsApiRestTasksBody2);
                Events.ExecuteOnErrorMoveTaskApiV1TasksTaskIdMovePost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MoveTaskApiV1TasksTaskIdMovePostApiResponse"/>
        /// </summary>
        public partial class MoveTaskApiV1TasksTaskIdMovePostApiResponse : Org.OpenAPITools.Client.ApiResponse, IMoveTaskApiV1TasksTaskIdMovePostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MoveTaskApiV1TasksTaskIdMovePostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MoveTaskApiV1TasksTaskIdMovePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MoveTaskApiV1TasksTaskIdMovePostApiResponse(ILogger<MoveTaskApiV1TasksTaskIdMovePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatQuickAddApiV1TasksQuickPost(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        /// <returns></returns>
        private void ValidateQuickAddApiV1TasksQuickPost(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody)
        {
            if (todoistAppsApiSyncRestQuickBody == null)
                throw new ArgumentNullException(nameof(todoistAppsApiSyncRestQuickBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        private void AfterQuickAddApiV1TasksQuickPostDefaultImplementation(IQuickAddApiV1TasksQuickPostApiResponse apiResponseLocalVar, TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody)
        {
            bool suppressDefaultLog = false;
            AfterQuickAddApiV1TasksQuickPost(ref suppressDefaultLog, apiResponseLocalVar, todoistAppsApiSyncRestQuickBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        partial void AfterQuickAddApiV1TasksQuickPost(ref bool suppressDefaultLog, IQuickAddApiV1TasksQuickPostApiResponse apiResponseLocalVar, TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        private void OnErrorQuickAddApiV1TasksQuickPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorQuickAddApiV1TasksQuickPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, todoistAppsApiSyncRestQuickBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        partial void OnErrorQuickAddApiV1TasksQuickPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody);

        /// <summary>
        /// Quick Add Add a new task using the Quick Add implementation similar to that used in the official clients
        /// </summary>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IQuickAddApiV1TasksQuickPostApiResponse"/>&gt;</returns>
        public async Task<IQuickAddApiV1TasksQuickPostApiResponse?> QuickAddApiV1TasksQuickPostOrDefaultAsync(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await QuickAddApiV1TasksQuickPostAsync(todoistAppsApiSyncRestQuickBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Quick Add Add a new task using the Quick Add implementation similar to that used in the official clients
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="todoistAppsApiSyncRestQuickBody"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IQuickAddApiV1TasksQuickPostApiResponse"/>&gt;</returns>
        public async Task<IQuickAddApiV1TasksQuickPostApiResponse> QuickAddApiV1TasksQuickPostAsync(TodoistAppsApiSyncRestQuickBody todoistAppsApiSyncRestQuickBody, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateQuickAddApiV1TasksQuickPost(todoistAppsApiSyncRestQuickBody);

                FormatQuickAddApiV1TasksQuickPost(todoistAppsApiSyncRestQuickBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/quick"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/quick");

                    httpRequestMessageLocalVar.Content = (todoistAppsApiSyncRestQuickBody as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiSyncRestQuickBody, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<QuickAddApiV1TasksQuickPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<QuickAddApiV1TasksQuickPostApiResponse>();

                        QuickAddApiV1TasksQuickPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/quick", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterQuickAddApiV1TasksQuickPostDefaultImplementation(apiResponseLocalVar, todoistAppsApiSyncRestQuickBody);

                        Events.ExecuteOnQuickAddApiV1TasksQuickPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorQuickAddApiV1TasksQuickPostDefaultImplementation(e, "/api/v1/tasks/quick", uriBuilderLocalVar.Path, todoistAppsApiSyncRestQuickBody);
                Events.ExecuteOnErrorQuickAddApiV1TasksQuickPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="QuickAddApiV1TasksQuickPostApiResponse"/>
        /// </summary>
        public partial class QuickAddApiV1TasksQuickPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IQuickAddApiV1TasksQuickPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<QuickAddApiV1TasksQuickPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="QuickAddApiV1TasksQuickPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public QuickAddApiV1TasksQuickPostApiResponse(ILogger<QuickAddApiV1TasksQuickPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Dictionary<string, Object>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, Object>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Dictionary<string, Object>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReopenTaskApiV1TasksTaskIdReopenPost(TaskId1 taskId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <returns></returns>
        private void ValidateReopenTaskApiV1TasksTaskIdReopenPost(TaskId1 taskId)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        private void AfterReopenTaskApiV1TasksTaskIdReopenPostDefaultImplementation(IReopenTaskApiV1TasksTaskIdReopenPostApiResponse apiResponseLocalVar, TaskId1 taskId)
        {
            bool suppressDefaultLog = false;
            AfterReopenTaskApiV1TasksTaskIdReopenPost(ref suppressDefaultLog, apiResponseLocalVar, taskId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        partial void AfterReopenTaskApiV1TasksTaskIdReopenPost(ref bool suppressDefaultLog, IReopenTaskApiV1TasksTaskIdReopenPostApiResponse apiResponseLocalVar, TaskId1 taskId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        private void OnErrorReopenTaskApiV1TasksTaskIdReopenPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId1 taskId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReopenTaskApiV1TasksTaskIdReopenPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        partial void OnErrorReopenTaskApiV1TasksTaskIdReopenPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId1 taskId);

        /// <summary>
        /// Reopen Task Reopens a task.  Any ancestor tasks or sections will also be marked as uncomplete and restored from history.  The reinstated tasks and sections will appear at the end of the list within their parent, after any previously active tasks.
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>&gt;</returns>
        public async Task<IReopenTaskApiV1TasksTaskIdReopenPostApiResponse?> ReopenTaskApiV1TasksTaskIdReopenPostOrDefaultAsync(TaskId1 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReopenTaskApiV1TasksTaskIdReopenPostAsync(taskId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reopen Task Reopens a task.  Any ancestor tasks or sections will also be marked as uncomplete and restored from history.  The reinstated tasks and sections will appear at the end of the list within their parent, after any previously active tasks.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>&gt;</returns>
        public async Task<IReopenTaskApiV1TasksTaskIdReopenPostApiResponse> ReopenTaskApiV1TasksTaskIdReopenPostAsync(TaskId1 taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReopenTaskApiV1TasksTaskIdReopenPost(taskId);

                FormatReopenTaskApiV1TasksTaskIdReopenPost(taskId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}/reopen"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}/reopen");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReopenTaskApiV1TasksTaskIdReopenPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReopenTaskApiV1TasksTaskIdReopenPostApiResponse>();

                        ReopenTaskApiV1TasksTaskIdReopenPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}/reopen", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReopenTaskApiV1TasksTaskIdReopenPostDefaultImplementation(apiResponseLocalVar, taskId);

                        Events.ExecuteOnReopenTaskApiV1TasksTaskIdReopenPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReopenTaskApiV1TasksTaskIdReopenPostDefaultImplementation(e, "/api/v1/tasks/{task_id}/reopen", uriBuilderLocalVar.Path, taskId);
                Events.ExecuteOnErrorReopenTaskApiV1TasksTaskIdReopenPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>
        /// </summary>
        public partial class ReopenTaskApiV1TasksTaskIdReopenPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IReopenTaskApiV1TasksTaskIdReopenPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReopenTaskApiV1TasksTaskIdReopenPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReopenTaskApiV1TasksTaskIdReopenPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReopenTaskApiV1TasksTaskIdReopenPostApiResponse(ILogger<ReopenTaskApiV1TasksTaskIdReopenPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref DateTime since, ref DateTime until, ref Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, ref Option<string?> filterQuery, ref Option<string?> filterLang, ref Option<string?> cursor, ref Option<int> limit, ref Option<string?> publicKey);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        private void AfterTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetDefaultImplementation(ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse apiResponseLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit, Option<string?> publicKey)
        {
            bool suppressDefaultLog = false;
            AfterTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref suppressDefaultLog, apiResponseLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, publicKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        partial void AfterTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref bool suppressDefaultLog, ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse apiResponseLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit, Option<string?> publicKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        private void OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit, Option<string?> publicKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, publicKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        /// <param name="publicKey"></param>
        partial void OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit, Option<string?> publicKey);

        /// <summary>
        /// Tasks Completed By Completion Date Retrieves a list of completed tasks strictly limited by the specified completion date range (up to 3 months).  It can retrieve completed items:  - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </summary>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>&gt;</returns>
        public async Task<ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse?> TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetOrDefaultAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetAsync(since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, publicKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Tasks Completed By Completion Date Retrieves a list of completed tasks strictly limited by the specified completion date range (up to 3 months).  It can retrieve completed items:  - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="publicKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>&gt;</returns>
        public async Task<ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse> TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, Option<string?> publicKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(ref since, ref until, ref workspaceId, projectId, sectionId, parentId, ref filterQuery, ref filterLang, ref cursor, ref limit, ref publicKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/completed/by_completion_date"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/completed/by_completion_date");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since);
                    parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until);

                    if (workspaceId.IsSet)
                        parseQueryStringLocalVar["workspace_id"] = ClientUtils.ParameterToString(workspaceId.Value);

                    if (projectId.IsSet)
                        parseQueryStringLocalVar["project_id"] = ClientUtils.ParameterToString(projectId.Value);

                    if (sectionId.IsSet)
                        parseQueryStringLocalVar["section_id"] = ClientUtils.ParameterToString(sectionId.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parent_id"] = ClientUtils.ParameterToString(parentId.Value);

                    if (filterQuery.IsSet)
                        parseQueryStringLocalVar["filter_query"] = ClientUtils.ParameterToString(filterQuery.Value);

                    if (filterLang.IsSet)
                        parseQueryStringLocalVar["filter_lang"] = ClientUtils.ParameterToString(filterLang.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (publicKey.IsSet)
                        parseQueryStringLocalVar["public_key"] = ClientUtils.ParameterToString(publicKey.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse>();

                        TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/completed/by_completion_date", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetDefaultImplementation(apiResponseLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, publicKey);

                        Events.ExecuteOnTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetDefaultImplementation(e, "/api/v1/tasks/completed/by_completion_date", uriBuilderLocalVar.Path, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, publicKey);
                Events.ExecuteOnErrorTasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>
        /// </summary>
        public partial class TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse : Org.OpenAPITools.Client.ApiResponse, ITasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse(ILogger<TasksCompletedByCompletionDateApiV1TasksCompletedByCompletionDateGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TasksCompletedDateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TasksCompletedDateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TasksCompletedDateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref DateTime since, ref DateTime until, ref Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, ref Option<string?> filterQuery, ref Option<string?> filterLang, ref Option<string?> cursor, ref Option<int> limit);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void AfterTasksCompletedByDueDateApiV1TasksCompletedByDueDateGetDefaultImplementation(ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse apiResponseLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref suppressDefaultLog, apiResponseLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void AfterTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref bool suppressDefaultLog, ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse apiResponseLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        private void OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"></param>
        /// <param name="projectId"></param>
        /// <param name="sectionId"></param>
        /// <param name="parentId"></param>
        /// <param name="filterQuery"></param>
        /// <param name="filterLang"></param>
        /// <param name="cursor"></param>
        /// <param name="limit"></param>
        partial void OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateTime since, DateTime until, Option<int?> workspaceId, Option<ProjectId2?> projectId, Option<SectionId1?> sectionId, Option<ParentId?> parentId, Option<string?> filterQuery, Option<string?> filterLang, Option<string?> cursor, Option<int> limit);

        /// <summary>
        /// Tasks Completed By Due Date Retrieves a list of completed items strictly limited by the specified due date range (up to 6 weeks).  It can retrieve completed items:  - From within a project, section, or parent item - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </summary>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>&gt;</returns>
        public async Task<ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse?> TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetOrDefaultAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetAsync(since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Tasks Completed By Due Date Retrieves a list of completed items strictly limited by the specified due date range (up to 6 weeks).  It can retrieve completed items:  - From within a project, section, or parent item - From all the projects the user has joined in a workspace - From all the projects of the user - That match many [supported   filters](https://todoist.com/help/articles/introduction-to-filters-V98wIH)  By default, the response is limited to a page containing a maximum of 50 items (configurable using &#x60;limit&#x60;).  Subsequent pages of results can be fetched by using the &#x60;next_cursor&#x60; value from the response as the &#x60;cursor&#x60; value for the next request.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="workspaceId"> (optional)</param>
        /// <param name="projectId"> (optional)</param>
        /// <param name="sectionId"> (optional)</param>
        /// <param name="parentId"> (optional)</param>
        /// <param name="filterQuery"> (optional)</param>
        /// <param name="filterLang"> (optional)</param>
        /// <param name="cursor"> (optional)</param>
        /// <param name="limit"> (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>&gt;</returns>
        public async Task<ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse> TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetAsync(DateTime since, DateTime until, Option<int?> workspaceId = default, Option<ProjectId2?> projectId = default, Option<SectionId1?> sectionId = default, Option<ParentId?> parentId = default, Option<string?> filterQuery = default, Option<string?> filterLang = default, Option<string?> cursor = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(ref since, ref until, ref workspaceId, projectId, sectionId, parentId, ref filterQuery, ref filterLang, ref cursor, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/completed/by_due_date"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/completed/by_due_date");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since);
                    parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until);

                    if (workspaceId.IsSet)
                        parseQueryStringLocalVar["workspace_id"] = ClientUtils.ParameterToString(workspaceId.Value);

                    if (projectId.IsSet)
                        parseQueryStringLocalVar["project_id"] = ClientUtils.ParameterToString(projectId.Value);

                    if (sectionId.IsSet)
                        parseQueryStringLocalVar["section_id"] = ClientUtils.ParameterToString(sectionId.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parent_id"] = ClientUtils.ParameterToString(parentId.Value);

                    if (filterQuery.IsSet)
                        parseQueryStringLocalVar["filter_query"] = ClientUtils.ParameterToString(filterQuery.Value);

                    if (filterLang.IsSet)
                        parseQueryStringLocalVar["filter_lang"] = ClientUtils.ParameterToString(filterLang.Value);

                    if (cursor.IsSet)
                        parseQueryStringLocalVar["cursor"] = ClientUtils.ParameterToString(cursor.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse>();

                        TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/completed/by_due_date", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterTasksCompletedByDueDateApiV1TasksCompletedByDueDateGetDefaultImplementation(apiResponseLocalVar, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit);

                        Events.ExecuteOnTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGetDefaultImplementation(e, "/api/v1/tasks/completed/by_due_date", uriBuilderLocalVar.Path, since, until, workspaceId, projectId, sectionId, parentId, filterQuery, filterLang, cursor, limit);
                Events.ExecuteOnErrorTasksCompletedByDueDateApiV1TasksCompletedByDueDateGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>
        /// </summary>
        public partial class TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse : Org.OpenAPITools.Client.ApiResponse, ITasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse(ILogger<TasksCompletedByDueDateApiV1TasksCompletedByDueDateGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TasksCompletedDateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TasksCompletedDateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TasksCompletedDateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateTaskApiV1TasksTaskIdPost(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        /// <returns></returns>
        private void ValidateUpdateTaskApiV1TasksTaskIdPost(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));

            if (todoistAppsApiRestTasksBody3 == null)
                throw new ArgumentNullException(nameof(todoistAppsApiRestTasksBody3));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        private void AfterUpdateTaskApiV1TasksTaskIdPostDefaultImplementation(IUpdateTaskApiV1TasksTaskIdPostApiResponse apiResponseLocalVar, TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3)
        {
            bool suppressDefaultLog = false;
            AfterUpdateTaskApiV1TasksTaskIdPost(ref suppressDefaultLog, apiResponseLocalVar, taskId, todoistAppsApiRestTasksBody3);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        partial void AfterUpdateTaskApiV1TasksTaskIdPost(ref bool suppressDefaultLog, IUpdateTaskApiV1TasksTaskIdPostApiResponse apiResponseLocalVar, TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        private void OnErrorUpdateTaskApiV1TasksTaskIdPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateTaskApiV1TasksTaskIdPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId, todoistAppsApiRestTasksBody3);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        partial void OnErrorUpdateTaskApiV1TasksTaskIdPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3);

        /// <summary>
        /// Update Task 
        /// </summary>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiV1TasksTaskIdPostApiResponse"/>&gt;</returns>
        public async Task<IUpdateTaskApiV1TasksTaskIdPostApiResponse?> UpdateTaskApiV1TasksTaskIdPostOrDefaultAsync(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateTaskApiV1TasksTaskIdPostAsync(taskId, todoistAppsApiRestTasksBody3, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId"></param>
        /// <param name="todoistAppsApiRestTasksBody3"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiV1TasksTaskIdPostApiResponse"/>&gt;</returns>
        public async Task<IUpdateTaskApiV1TasksTaskIdPostApiResponse> UpdateTaskApiV1TasksTaskIdPostAsync(TaskId2 taskId, TodoistAppsApiRestTasksBody3 todoistAppsApiRestTasksBody3, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateTaskApiV1TasksTaskIdPost(taskId, todoistAppsApiRestTasksBody3);

                FormatUpdateTaskApiV1TasksTaskIdPost(taskId, todoistAppsApiRestTasksBody3);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/tasks/{task_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/tasks/{task_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.Content = (todoistAppsApiRestTasksBody3 as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(todoistAppsApiRestTasksBody3, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateTaskApiV1TasksTaskIdPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateTaskApiV1TasksTaskIdPostApiResponse>();

                        UpdateTaskApiV1TasksTaskIdPostApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/tasks/{task_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateTaskApiV1TasksTaskIdPostDefaultImplementation(apiResponseLocalVar, taskId, todoistAppsApiRestTasksBody3);

                        Events.ExecuteOnUpdateTaskApiV1TasksTaskIdPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateTaskApiV1TasksTaskIdPostDefaultImplementation(e, "/api/v1/tasks/{task_id}", uriBuilderLocalVar.Path, taskId, todoistAppsApiRestTasksBody3);
                Events.ExecuteOnErrorUpdateTaskApiV1TasksTaskIdPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateTaskApiV1TasksTaskIdPostApiResponse"/>
        /// </summary>
        public partial class UpdateTaskApiV1TasksTaskIdPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateTaskApiV1TasksTaskIdPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateTaskApiV1TasksTaskIdPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateTaskApiV1TasksTaskIdPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTaskApiV1TasksTaskIdPostApiResponse(ILogger<UpdateTaskApiV1TasksTaskIdPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ItemSyncView? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ItemSyncView>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ItemSyncView? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
